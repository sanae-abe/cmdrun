--- src/command/executor.rs
+++ replace CommandExecutor::execute_parallel -> Result<Vec<ExecutionResult>> with Err(std::io::Error)
@@ -346,55 +346,17 @@
             eprintln!("{} {}", "→".cyan().bold(), command.bright_white());
         } else {
             eprintln!("→ {}", command);
         }
     }
 
     /// 複数コマンドを並列実行
     pub async fn execute_parallel(&self, commands: &[&Command]) -> Result<Vec<ExecutionResult>> {
-        if commands.is_empty() {
-            return Ok(Vec::new());
-        }
-
-        if self.context.color {
-            eprintln!(
-                "{} {} commands in parallel",
-                "⚡".yellow().bold(),
-                commands.len()
-            );
-        }
-
-        let mut set = JoinSet::new();
-
-        // 各コマンドを並列タスクとして起動
-        for command in commands {
-            let executor = self.clone_for_task();
-            let cmd = (*command).clone();
-
-            set.spawn(async move { executor.execute(&cmd).await });
-        }
-
-        // 全タスクの完了を待機
-        let mut results = Vec::new();
-        while let Some(result) = set.join_next().await {
-            match result {
-                Ok(Ok(exec_result)) => results.push(exec_result),
-                Ok(Err(e)) => return Err(e),
-                Err(e) => {
-                    return Err(ExecutionError::CommandFailed {
-                        command: format!("Parallel task failed: {}", e),
-                        code: 1,
-                    }
-                    .into())
-                }
-            }
-        }
-
-        Ok(results)
+        Err(std::io::Error) /* ~ changed by cargo-mutants ~ */
     }
 
     /// タスク用のクローンを作成
     fn clone_for_task(&self) -> Self {
         Self {
             context: self.context.clone(),
             validator: CommandValidator::new(),
             sensitive_env: SensitiveEnv::new(),
