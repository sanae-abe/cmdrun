--- src/command/executor.rs
+++ replace CommandExecutor::execute_single -> Result<ExecutionResult> with Ok(Default::default())
@@ -199,113 +199,17 @@
     }
 
     /// 単一コマンド実行
     async fn execute_single(
         &self,
         command: &str,
         env: &AHashMap<String, String>,
     ) -> Result<ExecutionResult> {
-        let start = Instant::now();
-
-        // セキュリティ検証
-        let validation_result = self.validator.validate(command);
-        if !validation_result.is_safe() {
-            if let Some(err) = validation_result.error() {
-                warn!("Command validation failed: {}", err);
-                return Err(ExecutionError::CommandFailed {
-                    command: command.to_string(),
-                    code: 1,
-                }
-                .into());
-            }
-        }
-
-        // コマンドエコー
-        if self.context.echo {
-            self.print_command(command);
-        }
-
-        // シェルビルトイン警告
-        self.warn_shell_builtin(command, self.context.language);
-
-        // シェルコマンド構築
-        let (shell, args) = self.build_shell_command(command);
-
-        // 環境変数のログ出力（機密情報マスキング）
-        if self.context.echo && !env.is_empty() {
-            let masked_env = self.sensitive_env.mask_ahash_map(env);
-            debug!("Environment variables: {:?}", masked_env);
-        }
-
-        // プロセス起動
-        let mut child = TokioCommand::new(&shell)
-            .args(&args)
-            .current_dir(&self.context.working_dir)
-            .envs(env)
-            .stdout(Stdio::piped())
-            .stderr(Stdio::piped())
-            .spawn()
-            .map_err(|e| ExecutionError::SpawnFailed {
-                command: command.to_string(),
-                source: e,
-            })?;
-
-        // 標準出力・エラー出力をキャプチャ
-        let stdout = child.stdout.take().unwrap();
-        let stderr = child.stderr.take().unwrap();
-
-        let stdout_reader = BufReader::new(stdout);
-        let stderr_reader = BufReader::new(stderr);
-
-        // 非同期出力読み取り
-        let stdout_handle = tokio::spawn(Self::read_output(stdout_reader, self.context.color));
-        let stderr_handle = tokio::spawn(Self::read_output(stderr_reader, self.context.color));
-
-        // タイムアウト付きプロセス待機
-        let status = if let Some(timeout_secs) = self.context.timeout {
-            match timeout(Duration::from_secs(timeout_secs), child.wait()).await {
-                Ok(result) => result.map_err(|e| ExecutionError::SpawnFailed {
-                    command: command.to_string(),
-                    source: e,
-                })?,
-                Err(_) => {
-                    // タイムアウト時はプロセスをキル
-                    let _ = child.kill().await;
-                    return Err(ExecutionError::Timeout {
-                        command: command.to_string(),
-                        timeout: timeout_secs,
-                    }
-                    .into());
-                }
-            }
-        } else {
-            child
-                .wait()
-                .await
-                .map_err(|e| ExecutionError::SpawnFailed {
-                    command: command.to_string(),
-                    source: e,
-                })?
-        };
-
-        // 出力取得
-        let stdout_output = stdout_handle.await.unwrap();
-        let stderr_output = stderr_handle.await.unwrap();
-
-        let duration = start.elapsed();
-        let exit_code = status.code().unwrap_or(-1);
-
-        Ok(ExecutionResult {
-            exit_code,
-            duration,
-            stdout: stdout_output,
-            stderr: stderr_output,
-            success: status.success(),
-        })
+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */
     }
 
     /// シェルコマンド構築
     fn build_shell_command(&self, command: &str) -> (String, Vec<String>) {
         let shell = &self.context.shell;
 
         if cfg!(windows) {
             if shell.contains("pwsh") || shell.contains("powershell") {
